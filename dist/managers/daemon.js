import { readAndParse } from "/managers/modules/helpers";
import { filesToSCP, globalFiles, serverConstants } from "/lib/constants";
export async function main(ns) {
    /** Primary target acquired! */
    const primaryTarget = await scoreTargetList(ns);
    /** Is the server prepped? If not, let's do that. */
    if (!primaryTarget.isPrepped) {
        /** build prep */
        await calculatePrep(ns, primaryTarget);
    }
    /** let's get time/thread calculations */
}
async function getTargetList(ns) {
    const targetList = await readAndParse(ns, globalFiles.targetMap);
    return targetList;
}
async function scoreTargetList(ns) {
    /** As a base to work from we're going to get the order of magnitude of the max money and use that. */
    /** now we have to calculate which one is the best, let's start with growth rate
     *  as a factor. The game formulas divide by 100, so will we, and multiply from the money max
     * calculation.
     */
    /** Then we've got the minimum security level, same idea, we'll divide by 10 and subtract from the
     * money max calculation.
     */
    const targetList = await getTargetList(ns);
    const targetScores = [];
    for (let i = 0; i < targetList.length; i++) {
        const targetOOM = Math.floor(Math.log10(targetList[i].moneyMax));
        const targetGrowScore = 1 + ((targetList[i].serverGrowth ?? 0) / 100);
        const targetMinSecScore = (targetList[i].minDifficulty ?? 1000) / 2;
        targetScores.push((targetOOM - targetMinSecScore) * targetGrowScore);
    }
    const highestValueIndex = targetScores.reduce((maxIndex, currentValue, currentIndex, array) => {
        if (currentValue > array[maxIndex]) {
            return currentIndex;
        }
        else {
            return maxIndex;
        }
    }, 0);
    return targetList[highestValueIndex];
}
async function getUsableServers(ns) {
    const curServMap = await readAndParse(ns, globalFiles.serverMap);
    const usableServers = curServMap.filter((servObj) => servObj.hasAdminRights === true);
    return usableServers;
}
function calculateAvailableThreads(usableServerList, ramPerThread) {
    return usableServerList.reduce((accumulator, servObj) => accumulator + Math.floor((servObj.ramMax - servObj.ramUsed) / ramPerThread), 0);
}
async function sendWave(ns, usableServerList, attackProgram, threadsNeeded, targetServer, targetDate, timeToComplete) {
    const attackRAMCost = attackProgramInformation(attackProgram, 'ramCost');
    const fileLocation = filesToSCP[attackProgramInformation(attackProgram, 'fileLocation')];
    const usableServers = usableServerList.filter((curServ) => (curServ.ramMax - curServ.ramUsed) > attackRAMCost);
    let waveCounter = 0;
    for (const attackingServer of usableServers) {
        let threadsToLaunch = Math.floor((attackingServer.ramMax - attackingServer.ramUsed) / attackRAMCost);
        if ((threadsNeeded - waveCounter) < threadsToLaunch) {
            threadsToLaunch = threadsNeeded - waveCounter;
        }
        ns.tprint("threads to Launch: " + threadsToLaunch + " / threadsNeeded: " + threadsNeeded + " / waveCounter: " + waveCounter);
        if (threadsToLaunch > 0) {
            if (await ns.exec(fileLocation, attackingServer.hostName, threadsToLaunch, targetServer, targetDate, timeToComplete) > 0) {
                waveCounter += threadsToLaunch;
            }
        }
    }
    return waveCounter;
}
function attackProgramInformation(attackProgram, informationRequested) {
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    let result = -1;
    switch (informationRequested) {
        case 'fileLocation':
            switch (attackProgram) {
                case 'grow':
                    result = 0;
                    break;
                case 'hack':
                    result = 1;
                    break;
                case 'weaken':
                    result = 2;
            }
            break;
        case 'ramCost':
            switch (attackProgram) {
                case 'grow':
                    result = serverConstants.ramCostGrow;
                    break;
                case 'hack':
                    result = serverConstants.ramCostHack;
                    break;
                case 'weaken':
                    result = serverConstants.ramCostWeaken;
            }
            break;
    }
    return result;
}
async function calculateGrowthThreadsNeeded(ns, primaryTarget) {
    const percentageToGrow = Math.ceil(primaryTarget.moneyMax / primaryTarget.moneyAvailable);
    const threadsNeeded = ns.growthAnalyze(primaryTarget.hostName, percentageToGrow);
    return threadsNeeded;
}
async function calculatePrep(ns, primaryTarget) {
    const usableServers = await getUsableServers(ns);
    const initialWeaken = Math.ceil((primaryTarget.hackDifficulty - primaryTarget.minDifficulty) / serverConstants.serverWeakenAmount);
    const growThreadsNeeded = await calculateGrowthThreadsNeeded(ns, primaryTarget);
    const secondWeakenNeeded = Math.ceil(growThreadsNeeded / 5) * 2;
    const lastAttackTime = new Date().getTime() + 10000;
    const timeToWeaken = await ns.getWeakenTime(primaryTarget.hostName);
    const timeToGrow = await ns.getGrowTime(primaryTarget.hostName);
    /** Can we do the initial weaken in one shot?, if not sleep til weaken fires then go back to servermanager */
    if (initialWeaken >= calculateAvailableThreads(usableServers, serverConstants.ramCostWeaken)) {
        const wavesCompleted = await sendWave(ns, usableServers, 'weaken', initialWeaken, primaryTarget.hostName, lastAttackTime, timeToWeaken);
        if (wavesCompleted > 0) {
            ns.tprint("something went wrong");
        }
        await ns.sleep(lastAttackTime + timeToWeaken + 5000);
        ns.spawn(globalFiles.serverManager, 1);
    }
    /** If we can, do the max weaken, then whatever we have left for grow/weaken */
    const canRunFullGrow = (await calculateAvailableThreads(usableServers, serverConstants.ramCostGrow) < (initialWeaken + growThreadsNeeded + secondWeakenNeeded));
    if (canRunFullGrow) {
        let wavesCompleted = await sendWave(ns, usableServers, 'weaken', initialWeaken, primaryTarget.hostName, lastAttackTime, timeToWeaken);
        wavesCompleted += await sendWave(ns, usableServers, 'grow', growThreadsNeeded, primaryTarget.hostName, lastAttackTime + 2000, timeToGrow);
        wavesCompleted += await sendWave(ns, usableServers, 'weaken', secondWeakenNeeded, primaryTarget.hostName, lastAttackTime + 4000, timeToWeaken);
        ns.tprint("Sent " + wavesCompleted + " to " + primaryTarget.hostName);
        await ns.sleep(lastAttackTime + timeToWeaken + 12000);
        ns.spawn(globalFiles.serverManager, 1);
    }
    else {
        const backupGrowthreads = Math.floor(await calculateAvailableThreads(usableServers, serverConstants.ramCostGrow) / 7);
        let wavesCompleted = await sendWave(ns, usableServers, 'weaken', initialWeaken, primaryTarget.hostName, lastAttackTime, timeToWeaken);
        wavesCompleted += await sendWave(ns, usableServers, 'grow', backupGrowthreads * 5, primaryTarget.hostName, lastAttackTime + 2000, timeToGrow);
        wavesCompleted += await sendWave(ns, usableServers, 'weaken', backupGrowthreads * 2, primaryTarget.hostName, lastAttackTime + 4000, timeToWeaken);
        ns.tprint("Sent " + wavesCompleted + " to " + primaryTarget.hostName);
        await ns.sleep(lastAttackTime + timeToWeaken + 12000);
        ns.spawn(globalFiles.serverManager, 1);
    }
}
/**
 * getGrowTime(host: string): number;
 * getWeakenTime(host: string): number;
 * getHackTime(host: string): number;
 * growthAnalyze(host: string, multiplier: number, cores?: number): number;
 * hackAnalyze(host: string): number;
 * hackAnalyzeThreads(host: string, hackAmount: number): number;
 */ 
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFlbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21hbmFnZXJzL2RhZW1vbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDekQsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUUsTUFBTSxDQUFDLEtBQUssVUFBVSxJQUFJLENBQUMsRUFBSztJQUM1QiwrQkFBK0I7SUFDL0IsTUFBTSxhQUFhLEdBQWdCLE1BQU0sZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRTdELG9EQUFvRDtJQUNwRCxJQUFHLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBQztRQUN4QixpQkFBaUI7UUFDakIsTUFBTSxhQUFhLENBQUMsRUFBRSxFQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQ3pDO0lBRUQseUNBQXlDO0FBQzdDLENBQUM7QUFFRCxLQUFLLFVBQVUsYUFBYSxDQUFDLEVBQUs7SUFDOUIsTUFBTSxVQUFVLEdBQWtCLE1BQU0sWUFBWSxDQUFDLEVBQUUsRUFBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDL0UsT0FBTyxVQUFVLENBQUM7QUFFdEIsQ0FBQztBQUVELEtBQUssVUFBVSxlQUFlLENBQUMsRUFBSztJQUVoQyxzR0FBc0c7SUFFdEc7OztPQUdHO0lBRUg7O09BRUc7SUFFSCxNQUFNLFVBQVUsR0FBa0IsTUFBTSxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDMUQsTUFBTSxZQUFZLEdBQVksRUFBRSxDQUFDO0lBQ2pDLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFDLENBQUMsRUFBRSxFQUFDO1FBQ3BDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FB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SyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekM7U0FBTTtRQUNILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDLGFBQWEsRUFBQyxlQUFlLENBQUMsV0FBVyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkgsSUFBSSxjQUFjLEdBQUcsTUFBTSxRQUFRLENBQUMsRUFBRSxFQUFDLGFBQWEsRUFBQyxRQUFRLEVBQUMsYUFBYSxFQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUMsY0FBYyxFQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ2hJLGNBQWMsSUFBSSxNQUFNLFFBQVEsQ0FBQyxFQUFFLEVBQUMsYUFBYSxFQUFDLE1BQU0sRUFBQyxpQkFBaUIsR0FBQyxDQUFDLEVBQUMsYUFBYSxDQUFDLFFBQVEsRUFBQyxjQUFjLEdBQUMsSUFBSSxFQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3BJLGNBQWMsSUFBSSxNQUFNLFFBQVEsQ0FBQyxFQUFFLEVBQUMsYUFBYSxFQUFDLFFBQVEsRUFBQyxpQkFBaUIsR0FBQyxDQUFDLEVBQUMsYUFBYSxDQUFDLFFBQVEsRUFBQyxjQUFjLEdBQUMsSUFBSSxFQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3hJLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLGNBQWMsR0FBRyxNQUFNLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ3JFLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsWUFBWSxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQ3RELEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBQyxDQUFDLENBQUMsQ0FBQztLQUN6QztBQUNMLENBQUM7QUFHRDs7Ozs7OztHQU9HIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTlMgfSBmcm9tIFwiQG5zXCI7XHJcbmltcG9ydCB7IHNlcnZlck9iamVjdCB9IGZyb20gXCIvY2xhc3Nlcy9jbGFzc1NlcnZlclwiO1xyXG5pbXBvcnQgeyByZWFkQW5kUGFyc2UgfSBmcm9tIFwiL21hbmFnZXJzL21vZHVsZXMvaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBmaWxlc1RvU0NQLCBnbG9iYWxGaWxlcywgc2VydmVyQ29uc3RhbnRzIH0gZnJvbSBcIi9saWIvY29uc3RhbnRzXCI7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFpbihuczpOUykge1xyXG4gICAgLyoqIFByaW1hcnkgdGFyZ2V0IGFjcXVpcmVkISAqL1xyXG4gICAgY29uc3QgcHJpbWFyeVRhcmdldDpzZXJ2ZXJPYmplY3QgPSBhd2FpdCBzY29yZVRhcmdldExpc3QobnMpO1xyXG5cclxuICAgIC8qKiBJcyB0aGUgc2VydmVyIHByZXBwZWQ/IElmIG5vdCwgbGV0J3MgZG8gdGhhdC4gKi9cclxuICAgIGlmKCFwcmltYXJ5VGFyZ2V0LmlzUHJlcHBlZCl7XHJcbiAgICAgICAgLyoqIGJ1aWxkIHByZXAgKi9cclxuICAgICAgICBhd2FpdCBjYWxjdWxhdGVQcmVwKG5zLHByaW1hcnlUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKiogbGV0J3MgZ2V0IHRpbWUvdGhyZWFkIGNhbGN1bGF0aW9ucyAqL1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRUYXJnZXRMaXN0KG5zOk5TKTpQcm9taXNlPEFycmF5PHNlcnZlck9iamVjdD4+e1xyXG4gICAgY29uc3QgdGFyZ2V0TGlzdDpzZXJ2ZXJPYmplY3RbXSA9IGF3YWl0IHJlYWRBbmRQYXJzZShucyxnbG9iYWxGaWxlcy50YXJnZXRNYXApO1xyXG4gICAgcmV0dXJuIHRhcmdldExpc3Q7XHJcblxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzY29yZVRhcmdldExpc3QobnM6TlMpOlByb21pc2U8c2VydmVyT2JqZWN0PntcclxuXHJcbiAgICAvKiogQXMgYSBiYXNlIHRvIHdvcmsgZnJvbSB3ZSdyZSBnb2luZyB0byBnZXQgdGhlIG9yZGVyIG9mIG1hZ25pdHVkZSBvZiB0aGUgbWF4IG1vbmV5IGFuZCB1c2UgdGhhdC4gKi9cclxuICAgIFxyXG4gICAgLyoqIG5vdyB3ZSBoYXZlIHRvIGNhbGN1bGF0ZSB3aGljaCBvbmUgaXMgdGhlIGJlc3QsIGxldCdzIHN0YXJ0IHdpdGggZ3Jvd3RoIHJhdGVcclxuICAgICAqICBhcyBhIGZhY3Rvci4gVGhlIGdhbWUgZm9ybXVsYXMgZGl2aWRlIGJ5IDEwMCwgc28gd2lsbCB3ZSwgYW5kIG11bHRpcGx5IGZyb20gdGhlIG1vbmV5IG1heFxyXG4gICAgICogY2FsY3VsYXRpb24uXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKiogVGhlbiB3ZSd2ZSBnb3QgdGhlIG1pbmltdW0gc2VjdXJpdHkgbGV2ZWwsIHNhbWUgaWRlYSwgd2UnbGwgZGl2aWRlIGJ5IDEwIGFuZCBzdWJ0cmFjdCBmcm9tIHRoZVxyXG4gICAgICogbW9uZXkgbWF4IGNhbGN1bGF0aW9uLlxyXG4gICAgICovXHJcblxyXG4gICAgY29uc3QgdGFyZ2V0TGlzdDpzZXJ2ZXJPYmplY3RbXSA9IGF3YWl0IGdldFRhcmdldExpc3QobnMpO1xyXG4gICAgY29uc3QgdGFyZ2V0U2NvcmVzOm51bWJlcltdID0gW107XHJcbiAgICBmb3IobGV0IGkgPSAwO2kgPCB0YXJnZXRMaXN0Lmxlbmd0aDtpKyspe1xyXG4gICAgICAgIGNvbnN0IHRhcmdldE9PTSA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMCh0YXJnZXRMaXN0W2ldLm1vbmV5TWF4KSk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0R3Jvd1Njb3JlID0gMSArICgodGFyZ2V0TGlzdFtpXS5zZXJ2ZXJHcm93dGggPz8gMCkvMTAwKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRNaW5TZWNTY29yZSA9ICh0YXJnZXRMaXN0W2ldLm1pbkRpZmZpY3VsdHkgPz8gMTAwMCkvMjtcclxuICAgICAgICB0YXJnZXRTY29yZXMucHVzaCgodGFyZ2V0T09NLXRhcmdldE1pblNlY1Njb3JlKSp0YXJnZXRHcm93U2NvcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhpZ2hlc3RWYWx1ZUluZGV4ID0gdGFyZ2V0U2NvcmVzLnJlZHVjZSgobWF4SW5kZXgsIGN1cnJlbnRWYWx1ZSwgY3VycmVudEluZGV4LCBhcnJheSkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiBhcnJheVttYXhJbmRleF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4SW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgMCk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldExpc3RbaGlnaGVzdFZhbHVlSW5kZXhdO1xyXG5cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VXNhYmxlU2VydmVycyhuczpOUyk6UHJvbWlzZTxzZXJ2ZXJPYmplY3RbXT57XHJcbiAgICBjb25zdCBjdXJTZXJ2TWFwOnNlcnZlck9iamVjdFtdID0gYXdhaXQgcmVhZEFuZFBhcnNlKG5zLGdsb2JhbEZpbGVzLnNlcnZlck1hcCk7XHJcbiAgICBjb25zdCB1c2FibGVTZXJ2ZXJzOnNlcnZlck9iamVjdFtdID0gY3VyU2Vydk1hcC5maWx0ZXIoKHNlcnZPYmopID0+IHNlcnZPYmouaGFzQWRtaW5SaWdodHMgPT09IHRydWUpO1xyXG4gICAgcmV0dXJuIHVzYWJsZVNlcnZlcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUF2YWlsYWJsZVRocmVhZHModXNhYmxlU2VydmVyTGlzdDpzZXJ2ZXJPYmplY3RbXSxyYW1QZXJUaHJlYWQ6bnVtYmVyKTpudW1iZXJ7XHJcbiAgICByZXR1cm4gdXNhYmxlU2VydmVyTGlzdC5yZWR1Y2UoKGFjY3VtdWxhdG9yLHNlcnZPYmopID0+IGFjY3VtdWxhdG9yICsgTWF0aC5mbG9vcigoc2Vydk9iai5yYW1NYXgtc2Vydk9iai5yYW1Vc2VkKS9yYW1QZXJUaHJlYWQpLDApXHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRXYXZlKG5zOk5TLHVzYWJsZVNlcnZlckxpc3Q6c2VydmVyT2JqZWN0W10sYXR0YWNrUHJvZ3JhbTpzdHJpbmcsdGhyZWFkc05lZWRlZDpudW1iZXIsdGFyZ2V0U2VydmVyOnN0cmluZyx0YXJnZXREYXRlOm51bWJlcix0aW1lVG9Db21wbGV0ZTpudW1iZXIpOlByb21pc2U8bnVtYmVyPntcclxuICAgIGNvbnN0IGF0dGFja1JBTUNvc3Q6bnVtYmVyID0gYXR0YWNrUHJvZ3JhbUluZm9ybWF0aW9uKGF0dGFja1Byb2dyYW0sJ3JhbUNvc3QnKTtcclxuICAgIGNvbnN0IGZpbGVMb2NhdGlvbjpzdHJpbmcgPSBmaWxlc1RvU0NQW2F0dGFja1Byb2dyYW1JbmZvcm1hdGlvbihhdHRhY2tQcm9ncmFtLCdmaWxlTG9jYXRpb24nKV07XHJcbiAgICBjb25zdCB1c2FibGVTZXJ2ZXJzOnNlcnZlck9iamVjdFtdID0gdXNhYmxlU2VydmVyTGlzdC5maWx0ZXIoKGN1clNlcnYpID0+IChjdXJTZXJ2LnJhbU1heC1jdXJTZXJ2LnJhbVVzZWQpID4gYXR0YWNrUkFNQ29zdClcclxuICAgIGxldCB3YXZlQ291bnRlciA9IDA7XHJcbiAgICBmb3IoY29uc3QgYXR0YWNraW5nU2VydmVyIG9mIHVzYWJsZVNlcnZlcnMpe1xyXG4gICAgICAgIGxldCB0aHJlYWRzVG9MYXVuY2ggPSBNYXRoLmZsb29yKChhdHRhY2tpbmdTZXJ2ZXIucmFtTWF4LWF0dGFja2luZ1NlcnZlci5yYW1Vc2VkKS9hdHRhY2tSQU1Db3N0KTtcclxuICAgICAgICBpZigodGhyZWFkc05lZWRlZC13YXZlQ291bnRlcik8dGhyZWFkc1RvTGF1bmNoKXtcclxuICAgICAgICAgICAgdGhyZWFkc1RvTGF1bmNoID0gdGhyZWFkc05lZWRlZC13YXZlQ291bnRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbnMudHByaW50KFwidGhyZWFkcyB0byBMYXVuY2g6IFwiICt0aHJlYWRzVG9MYXVuY2grXCIgLyB0aHJlYWRzTmVlZGVkOiBcIiArdGhyZWFkc05lZWRlZCArIFwiIC8gd2F2ZUNvdW50ZXI6IFwiICsgd2F2ZUNvdW50ZXIgKVxyXG4gICAgICAgIGlmKHRocmVhZHNUb0xhdW5jaCA+IDApe1xyXG4gICAgICAgIGlmKGF3YWl0IG5zLmV4ZWMoZmlsZUxvY2F0aW9uLGF0dGFja2luZ1NlcnZlci5ob3N0TmFtZSx0aHJlYWRzVG9MYXVuY2gsdGFyZ2V0U2VydmVyLHRhcmdldERhdGUsdGltZVRvQ29tcGxldGUpID4gMCl7XHJcbiAgICAgICAgICAgIHdhdmVDb3VudGVyICs9IHRocmVhZHNUb0xhdW5jaDtcclxuICAgICAgICB9fVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gd2F2ZUNvdW50ZXI7XHJcbn1cclxuZnVuY3Rpb24gYXR0YWNrUHJvZ3JhbUluZm9ybWF0aW9uKGF0dGFja1Byb2dyYW06IHN0cmluZywgaW5mb3JtYXRpb25SZXF1ZXN0ZWQ6IHN0cmluZyk6bnVtYmVyIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xyXG4gICAgbGV0IHJlc3VsdDpudW1iZXIgPSAtMTtcclxuXHJcbiAgICBzd2l0Y2ggKGluZm9ybWF0aW9uUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgY2FzZSAnZmlsZUxvY2F0aW9uJzpcclxuICAgICAgICAgICAgc3dpdGNoIChhdHRhY2tQcm9ncmFtKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdncm93JzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaGFjayc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3dlYWtlbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAncmFtQ29zdCc6XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYXR0YWNrUHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3Jvdyc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VydmVyQ29uc3RhbnRzLnJhbUNvc3RHcm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaGFjayc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VydmVyQ29uc3RhbnRzLnJhbUNvc3RIYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vha2VuJzpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXJ2ZXJDb25zdGFudHMucmFtQ29zdFdlYWtlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUdyb3d0aFRocmVhZHNOZWVkZWQobnM6TlMscHJpbWFyeVRhcmdldDpzZXJ2ZXJPYmplY3QpOlByb21pc2U8bnVtYmVyPntcclxuICAgIGNvbnN0IHBlcmNlbnRhZ2VUb0dyb3cgPSBNYXRoLmNlaWwocHJpbWFyeVRhcmdldC5tb25leU1heC9wcmltYXJ5VGFyZ2V0Lm1vbmV5QXZhaWxhYmxlKTtcclxuICAgIGNvbnN0IHRocmVhZHNOZWVkZWQgPSBucy5ncm93dGhBbmFseXplKHByaW1hcnlUYXJnZXQuaG9zdE5hbWUscGVyY2VudGFnZVRvR3JvdylcclxuICAgIHJldHVybiB0aHJlYWRzTmVlZGVkO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVQcmVwKG5zOk5TLHByaW1hcnlUYXJnZXQ6c2VydmVyT2JqZWN0KXtcclxuICAgIGNvbnN0IHVzYWJsZVNlcnZlcnM6c2VydmVyT2JqZWN0W10gPSBhd2FpdCBnZXRVc2FibGVTZXJ2ZXJzKG5zKTtcclxuICAgIGNvbnN0IGluaXRpYWxXZWFrZW46bnVtYmVyID0gTWF0aC5jZWlsKChwcmltYXJ5VGFyZ2V0LmhhY2tEaWZmaWN1bHR5LXByaW1hcnlUYXJnZXQubWluRGlmZmljdWx0eSkvc2VydmVyQ29uc3RhbnRzLnNlcnZlcldlYWtlbkFtb3VudCk7XHJcbiAgICBjb25zdCBncm93VGhyZWFkc05lZWRlZCA9IGF3YWl0IGNhbGN1bGF0ZUdyb3d0aFRocmVhZHNOZWVkZWQobnMscHJpbWFyeVRhcmdldCk7XHJcbiAgICBjb25zdCBzZWNvbmRXZWFrZW5OZWVkZWQgPSBNYXRoLmNlaWwoZ3Jvd1RocmVhZHNOZWVkZWQvNSkqMjtcclxuICAgIGNvbnN0IGxhc3RBdHRhY2tUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkrMTAwMDA7XHJcbiAgICBjb25zdCB0aW1lVG9XZWFrZW4gPSBhd2FpdCBucy5nZXRXZWFrZW5UaW1lKHByaW1hcnlUYXJnZXQuaG9zdE5hbWUpO1xyXG4gICAgY29uc3QgdGltZVRvR3JvdyA9IGF3YWl0IG5zLmdldEdyb3dUaW1lKHByaW1hcnlUYXJnZXQuaG9zdE5hbWUpO1xyXG4gICAgLyoqIENhbiB3ZSBkbyB0aGUgaW5pdGlhbCB3ZWFrZW4gaW4gb25lIHNob3Q/LCBpZiBub3Qgc2xlZXAgdGlsIHdlYWtlbiBmaXJlcyB0aGVuIGdvIGJhY2sgdG8gc2VydmVybWFuYWdlciAqL1xyXG4gICAgaWYoaW5pdGlhbFdlYWtlbiA+PSBjYWxjdWxhdGVBdmFpbGFibGVUaHJlYWRzKHVzYWJsZVNlcnZlcnMsc2VydmVyQ29uc3RhbnRzLnJhbUNvc3RXZWFrZW4pKXtcclxuICAgICAgICBjb25zdCB3YXZlc0NvbXBsZXRlZCA9IGF3YWl0IHNlbmRXYXZlKG5zLHVzYWJsZVNlcnZlcnMsJ3dlYWtlbicsaW5pdGlhbFdlYWtlbixwcmltYXJ5VGFyZ2V0Lmhvc3ROYW1lLGxhc3RBdHRhY2tUaW1lLHRpbWVUb1dlYWtlbik7XHJcbiAgICAgICAgaWYod2F2ZXNDb21wbGV0ZWQgPiAwKXtcclxuICAgICAgICAgICAgbnMudHByaW50KFwic29tZXRoaW5nIHdlbnQgd3JvbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IG5zLnNsZWVwKGxhc3RBdHRhY2tUaW1lICsgdGltZVRvV2Vha2VuICsgNTAwMCk7XHJcbiAgICAgICAgbnMuc3Bhd24oZ2xvYmFsRmlsZXMuc2VydmVyTWFuYWdlciwxKTtcclxuICAgIH1cclxuICAgIC8qKiBJZiB3ZSBjYW4sIGRvIHRoZSBtYXggd2Vha2VuLCB0aGVuIHdoYXRldmVyIHdlIGhhdmUgbGVmdCBmb3IgZ3Jvdy93ZWFrZW4gKi9cclxuICAgIGNvbnN0IGNhblJ1bkZ1bGxHcm93OmJvb2xlYW4gPSAoYXdhaXQgY2FsY3VsYXRlQXZhaWxhYmxlVGhyZWFkcyh1c2FibGVTZXJ2ZXJzLHNlcnZlckNvbnN0YW50cy5yYW1Db3N0R3JvdykgPCAoaW5pdGlhbFdlYWtlbitncm93VGhyZWFkc05lZWRlZCtzZWNvbmRXZWFrZW5OZWVkZWQpKTtcclxuICAgIGlmKGNhblJ1bkZ1bGxHcm93KXtcclxuICAgICAgICBsZXQgd2F2ZXNDb21wbGV0ZWQgPSBhd2FpdCBzZW5kV2F2ZShucyx1c2FibGVTZXJ2ZXJzLCd3ZWFrZW4nLGluaXRpYWxXZWFrZW4scHJpbWFyeVRhcmdldC5ob3N0TmFtZSxsYXN0QXR0YWNrVGltZSx0aW1lVG9XZWFrZW4pO1xyXG4gICAgICAgIHdhdmVzQ29tcGxldGVkICs9IGF3YWl0IHNlbmRXYXZlKG5zLHVzYWJsZVNlcnZlcnMsJ2dyb3cnLGdyb3dUaHJlYWRzTmVlZGVkLHByaW1hcnlUYXJnZXQuaG9zdE5hbWUsbGFzdEF0dGFja1RpbWUrMjAwMCx0aW1lVG9Hcm93KTtcclxuICAgICAgICB3YXZlc0NvbXBsZXRlZCArPSBhd2FpdCBzZW5kV2F2ZShucyx1c2FibGVTZXJ2ZXJzLCd3ZWFrZW4nLHNlY29uZFdlYWtlbk5lZWRlZCxwcmltYXJ5VGFyZ2V0Lmhvc3ROYW1lLGxhc3RBdHRhY2tUaW1lKzQwMDAsdGltZVRvV2Vha2VuKTtcclxuICAgICAgICBucy50cHJpbnQoXCJTZW50IFwiICsgd2F2ZXNDb21wbGV0ZWQgKyBcIiB0byBcIiArIHByaW1hcnlUYXJnZXQuaG9zdE5hbWUpXHJcbiAgICAgICAgYXdhaXQgbnMuc2xlZXAobGFzdEF0dGFja1RpbWUgKyB0aW1lVG9XZWFrZW4gKyAxMjAwMCk7XHJcbiAgICAgICAgbnMuc3Bhd24oZ2xvYmFsRmlsZXMuc2VydmVyTWFuYWdlciwxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYmFja3VwR3Jvd3RocmVhZHMgPSBNYXRoLmZsb29yKGF3YWl0IGNhbGN1bGF0ZUF2YWlsYWJsZVRocmVhZHModXNhYmxlU2VydmVycyxzZXJ2ZXJDb25zdGFudHMucmFtQ29zdEdyb3cpLzcpO1xyXG4gICAgICAgIGxldCB3YXZlc0NvbXBsZXRlZCA9IGF3YWl0IHNlbmRXYXZlKG5zLHVzYWJsZVNlcnZlcnMsJ3dlYWtlbicsaW5pdGlhbFdlYWtlbixwcmltYXJ5VGFyZ2V0Lmhvc3ROYW1lLGxhc3RBdHRhY2tUaW1lLHRpbWVUb1dlYWtlbik7XHJcbiAgICAgICAgd2F2ZXNDb21wbGV0ZWQgKz0gYXdhaXQgc2VuZFdhdmUobnMsdXNhYmxlU2VydmVycywnZ3JvdycsYmFja3VwR3Jvd3RocmVhZHMqNSxwcmltYXJ5VGFyZ2V0Lmhvc3ROYW1lLGxhc3RBdHRhY2tUaW1lKzIwMDAsdGltZVRvR3Jvdyk7XHJcbiAgICAgICAgd2F2ZXNDb21wbGV0ZWQgKz0gYXdhaXQgc2VuZFdhdmUobnMsdXNhYmxlU2VydmVycywnd2Vha2VuJyxiYWNrdXBHcm93dGhyZWFkcyoyLHByaW1hcnlUYXJnZXQuaG9zdE5hbWUsbGFzdEF0dGFja1RpbWUrNDAwMCx0aW1lVG9XZWFrZW4pO1xyXG4gICAgICAgIG5zLnRwcmludChcIlNlbnQgXCIgKyB3YXZlc0NvbXBsZXRlZCArIFwiIHRvIFwiICsgcHJpbWFyeVRhcmdldC5ob3N0TmFtZSlcclxuICAgICAgICBhd2FpdCBucy5zbGVlcChsYXN0QXR0YWNrVGltZSArIHRpbWVUb1dlYWtlbiArIDEyMDAwKTtcclxuICAgICAgICBucy5zcGF3bihnbG9iYWxGaWxlcy5zZXJ2ZXJNYW5hZ2VyLDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGdldEdyb3dUaW1lKGhvc3Q6IHN0cmluZyk6IG51bWJlcjtcclxuICogZ2V0V2Vha2VuVGltZShob3N0OiBzdHJpbmcpOiBudW1iZXI7XHJcbiAqIGdldEhhY2tUaW1lKGhvc3Q6IHN0cmluZyk6IG51bWJlcjtcclxuICogZ3Jvd3RoQW5hbHl6ZShob3N0OiBzdHJpbmcsIG11bHRpcGxpZXI6IG51bWJlciwgY29yZXM/OiBudW1iZXIpOiBudW1iZXI7XHJcbiAqIGhhY2tBbmFseXplKGhvc3Q6IHN0cmluZyk6IG51bWJlcjtcclxuICogaGFja0FuYWx5emVUaHJlYWRzKGhvc3Q6IHN0cmluZywgaGFja0Ftb3VudDogbnVtYmVyKTogbnVtYmVyO1xyXG4gKi8iXX0=